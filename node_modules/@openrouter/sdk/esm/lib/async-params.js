/**
 * Type guard to check if a value is a parameter function
 * Parameter functions take TurnContext and return a value or promise
 */
function isParameterFunction(value) {
    return typeof value === 'function';
}
/**
 * Build a resolved request object from entries
 * This validates the structure matches the expected ResolvedCallModelInput shape
 */
function buildResolvedRequest(entries) {
    const obj = Object.fromEntries(entries);
    return obj;
}
/**
 * Resolve all async functions in CallModelInput to their values
 *
 * @param input - Input with possible functions
 * @param context - Turn context for function execution
 * @returns Resolved input with all values (no functions)
 *
 * @example
 * ```typescript
 * const resolved = await resolveAsyncFunctions(
 *   {
 *     model: 'gpt-4',
 *     temperature: (ctx) => ctx.numberOfTurns * 0.1,
 *     input: 'Hello',
 *   },
 *   { numberOfTurns: 2, messageHistory: [] }
 * );
 * // resolved.temperature === 0.2
 * ```
 */
export async function resolveAsyncFunctions(input, context) {
    // Build array of resolved entries
    const resolvedEntries = [];
    // Iterate over all keys in the input
    for (const [key, value] of Object.entries(input)) {
        // Skip stopWhen - it's handled separately in ModelResult
        // Note: tools are already in API format at this point (converted in callModel()), so we include them
        if (key === 'stopWhen') {
            continue;
        }
        if (isParameterFunction(value)) {
            try {
                // Execute the function with context and store the result
                const result = await Promise.resolve(value(context));
                resolvedEntries.push([key, result]);
            }
            catch (error) {
                // Wrap errors with context about which field failed
                throw new Error(`Failed to resolve async function for field "${key}": ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        else {
            // Not a function, use as-is
            resolvedEntries.push([key, value]);
        }
    }
    return buildResolvedRequest(resolvedEntries);
}
/**
 * Check if input has any async functions that need resolution
 *
 * @param input - Input to check
 * @returns True if any field is a function
 */
export function hasAsyncFunctions(input) {
    if (!input || typeof input !== 'object') {
        return false;
    }
    return Object.values(input).some((value) => typeof value === 'function');
}
//# sourceMappingURL=async-params.js.map