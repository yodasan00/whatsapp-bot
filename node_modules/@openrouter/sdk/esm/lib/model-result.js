import { ToolEventBroadcaster } from './tool-event-broadcaster.js';
import { betaResponsesSend } from '../funcs/betaResponsesSend.js';
import { hasAsyncFunctions, resolveAsyncFunctions, } from './async-params.js';
import { ReusableReadableStream } from './reusable-stream.js';
import { buildResponsesMessageStream, buildToolCallStream, consumeStreamForCompletion, extractReasoningDeltas, extractResponsesMessageFromResponse, extractTextDeltas, extractTextFromResponse, extractToolCallsFromResponse, extractToolDeltas, } from './stream-transformers.js';
import { executeTool } from './tool-executor.js';
import { executeNextTurnParamsFunctions, applyNextTurnParamsToRequest } from './next-turn-params.js';
import { hasExecuteFunction } from './tool-types.js';
import { isStopConditionMet } from './stop-conditions.js';
/**
 * Type guard for stream event with toReadableStream method
 */
function isEventStream(value) {
    return (value !== null &&
        typeof value === 'object' &&
        'toReadableStream' in value &&
        typeof value.toReadableStream === 'function');
}
/**
 * Type guard for output items with a type property
 */
function hasTypeProperty(item) {
    return (typeof item === 'object' &&
        item !== null &&
        'type' in item &&
        typeof item.type === 'string');
}
/**
 * A wrapper around a streaming response that provides multiple consumption patterns.
 *
 * Allows consuming the response in multiple ways:
 * - `await result.getText()` - Get just the text
 * - `await result.getResponse()` - Get the full response object
 * - `for await (const delta of result.getTextStream())` - Stream text deltas
 * - `for await (const msg of result.getNewMessagesStream())` - Stream incremental message updates
 * - `for await (const event of result.getFullResponsesStream())` - Stream all response events
 *
 * For message format conversion, use the helper functions:
 * - `toChatMessage(response)` for OpenAI chat format
 * - `toClaudeMessage(response)` for Anthropic Claude format
 *
 * All consumption patterns can be used concurrently thanks to the underlying
 * ReusableReadableStream implementation.
 *
 * @template TTools - The tools array type to enable typed tool calls and results
 */
export class ModelResult {
    constructor(options) {
        this.reusableStream = null;
        this.streamPromise = null;
        this.textPromise = null;
        this.initPromise = null;
        this.toolExecutionPromise = null;
        this.finalResponse = null;
        this.toolEventBroadcaster = null;
        this.allToolExecutionRounds = [];
        // Track resolved request after async function resolution
        this.resolvedRequest = null;
        this.options = options;
    }
    /**
     * Get or create the tool event broadcaster (lazy initialization).
     * Ensures only one broadcaster exists for the lifetime of this ModelResult.
     */
    ensureBroadcaster() {
        if (!this.toolEventBroadcaster) {
            this.toolEventBroadcaster = new ToolEventBroadcaster();
        }
        return this.toolEventBroadcaster;
    }
    /**
     * Type guard to check if a value is a non-streaming response
     */
    isNonStreamingResponse(value) {
        return (value !== null &&
            typeof value === 'object' &&
            'id' in value &&
            'object' in value &&
            'output' in value &&
            !('toReadableStream' in value));
    }
    /**
     * Initialize the stream if not already started
     * This is idempotent - multiple calls will return the same promise
     */
    initStream() {
        if (this.initPromise) {
            return this.initPromise;
        }
        this.initPromise = (async () => {
            // Resolve async functions before initial request
            // Build initial turn context (turn 0 for initial request)
            const initialContext = {
                numberOfTurns: 0,
            };
            // Resolve any async functions first
            let baseRequest;
            if (hasAsyncFunctions(this.options.request)) {
                baseRequest = await resolveAsyncFunctions(this.options.request, initialContext);
            }
            else {
                // Already resolved, extract non-function fields
                // Since request is CallModelInput, we need to filter out stopWhen
                // Note: tools are already in API format at this point (converted in callModel())
                const { stopWhen: _, ...rest } = this.options.request;
                // Cast to ResolvedCallModelInput - we know it's resolved if hasAsyncFunctions returned false
                baseRequest = rest;
            }
            // Store resolved request with stream mode
            this.resolvedRequest = {
                ...baseRequest,
                stream: true,
            };
            // Force stream mode for initial request
            const request = this.resolvedRequest;
            // Create the stream promise
            this.streamPromise = betaResponsesSend(this.options.client, request, this.options.options).then((result) => {
                if (!result.ok) {
                    throw result.error;
                }
                // When stream: true, the API returns EventStream
                // TypeScript can't narrow the union type based on runtime parameter values,
                // so we assert the type here based on our knowledge that stream=true
                return result.value;
            });
            // Wait for the stream and create the reusable stream
            const eventStream = await this.streamPromise;
            this.reusableStream = new ReusableReadableStream(eventStream);
        })();
        return this.initPromise;
    }
    /**
     * Execute tools automatically if they are provided and have execute functions
     * This is idempotent - multiple calls will return the same promise
     */
    async executeToolsIfNeeded() {
        if (this.toolExecutionPromise) {
            return this.toolExecutionPromise;
        }
        this.toolExecutionPromise = (async () => {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            // Note: Async functions already resolved in initStream()
            // Get the initial response
            const initialResponse = await consumeStreamForCompletion(this.reusableStream);
            // Check if we have tools and if auto-execution is enabled
            const shouldAutoExecute = this.options.tools &&
                this.options.tools.length > 0 &&
                initialResponse.output.some((item) => hasTypeProperty(item) && item.type === 'function_call');
            if (!shouldAutoExecute) {
                // No tools to execute, use initial response
                this.finalResponse = initialResponse;
                return;
            }
            // Extract tool calls
            const toolCalls = extractToolCallsFromResponse(initialResponse);
            // Check if any have execute functions
            const executableTools = toolCalls.filter((toolCall) => {
                const tool = this.options.tools?.find((t) => t.function.name === toolCall.name);
                return tool && hasExecuteFunction(tool);
            });
            if (executableTools.length === 0) {
                // No executable tools, use initial response
                this.finalResponse = initialResponse;
                return;
            }
            let currentResponse = initialResponse;
            let currentRound = 0;
            while (true) {
                // Check stopWhen conditions
                if (this.options.stopWhen) {
                    const stopConditions = Array.isArray(this.options.stopWhen)
                        ? this.options.stopWhen
                        : [this.options.stopWhen];
                    const shouldStop = await isStopConditionMet({
                        stopConditions,
                        steps: this.allToolExecutionRounds.map((round) => ({
                            stepType: 'continue',
                            text: extractTextFromResponse(round.response),
                            toolCalls: round.toolCalls,
                            toolResults: round.toolResults.map((tr) => ({
                                toolCallId: tr.callId,
                                toolName: round.toolCalls.find((tc) => tc.id === tr.callId)?.name ?? '',
                                result: JSON.parse(tr.output),
                            })),
                            response: round.response,
                            usage: round.response.usage,
                            finishReason: undefined, // OpenResponsesNonStreamingResponse doesn't have finishReason
                        })),
                    });
                    if (shouldStop) {
                        break;
                    }
                }
                const currentToolCalls = extractToolCallsFromResponse(currentResponse);
                if (currentToolCalls.length === 0) {
                    break;
                }
                const hasExecutable = currentToolCalls.some((toolCall) => {
                    const tool = this.options.tools?.find((t) => t.function.name === toolCall.name);
                    return tool && hasExecuteFunction(tool);
                });
                if (!hasExecutable) {
                    break;
                }
                // Build turn context for this round (for async parameter resolution only)
                const turnContext = {
                    numberOfTurns: currentRound + 1, // 1-indexed
                };
                // Resolve async functions for this turn
                if (hasAsyncFunctions(this.options.request)) {
                    const resolved = await resolveAsyncFunctions(this.options.request, turnContext);
                    // Update resolved request with new values
                    this.resolvedRequest = {
                        ...resolved,
                        stream: false, // Tool execution turns don't need streaming
                    };
                }
                // Execute all tool calls
                const toolResults = [];
                for (const toolCall of currentToolCalls) {
                    const tool = this.options.tools?.find((t) => t.function.name === toolCall.name);
                    if (!tool || !hasExecuteFunction(tool)) {
                        continue;
                    }
                    // Create callback for real-time preliminary results
                    const onPreliminaryResult = this.toolEventBroadcaster
                        ? (callId, resultValue) => {
                            this.toolEventBroadcaster?.push({
                                type: 'preliminary_result',
                                toolCallId: callId,
                                result: resultValue,
                            });
                        }
                        : undefined;
                    const result = await executeTool(tool, toolCall, turnContext, onPreliminaryResult);
                    toolResults.push({
                        type: 'function_call_output',
                        id: `output_${toolCall.id}`,
                        callId: toolCall.id,
                        output: result.error
                            ? JSON.stringify({
                                error: result.error.message,
                            })
                            : JSON.stringify(result.result),
                    });
                }
                // Store execution round info including tool results
                this.allToolExecutionRounds.push({
                    round: currentRound,
                    toolCalls: currentToolCalls,
                    response: currentResponse,
                    toolResults,
                });
                // Execute nextTurnParams functions for tools that were called
                if (this.options.tools && currentToolCalls.length > 0) {
                    if (!this.resolvedRequest) {
                        throw new Error('Request not initialized');
                    }
                    const computedParams = await executeNextTurnParamsFunctions(currentToolCalls, this.options.tools, this.resolvedRequest);
                    // Apply computed parameters to the resolved request for next turn
                    if (Object.keys(computedParams).length > 0) {
                        this.resolvedRequest = applyNextTurnParamsToRequest(this.resolvedRequest, computedParams);
                    }
                }
                // Build new input with tool results
                // For the Responses API, we need to include the tool results in the input
                const newInput = [
                    ...(Array.isArray(currentResponse.output)
                        ? currentResponse.output
                        : [
                            currentResponse.output,
                        ]),
                    ...toolResults,
                ];
                // Make new request with tool results
                if (!this.resolvedRequest) {
                    throw new Error('Request not initialized');
                }
                const newRequest = {
                    ...this.resolvedRequest,
                    input: newInput,
                    stream: false,
                };
                const newResult = await betaResponsesSend(this.options.client, newRequest, this.options.options);
                if (!newResult.ok) {
                    throw newResult.error;
                }
                // Handle the result - it might be a stream or a response
                const value = newResult.value;
                if (isEventStream(value)) {
                    // It's a stream, consume it
                    const stream = new ReusableReadableStream(value);
                    currentResponse = await consumeStreamForCompletion(stream);
                }
                else if (this.isNonStreamingResponse(value)) {
                    currentResponse = value;
                }
                else {
                    throw new Error('Unexpected response type from API');
                }
                currentRound++;
            }
            // Validate the final response has required fields
            if (!currentResponse || !currentResponse.id || !currentResponse.output) {
                throw new Error('Invalid final response: missing required fields');
            }
            // Ensure the response is in a completed state (has output content)
            if (!Array.isArray(currentResponse.output) || currentResponse.output.length === 0) {
                throw new Error('Invalid final response: empty or invalid output');
            }
            this.finalResponse = currentResponse;
        })();
        return this.toolExecutionPromise;
    }
    /**
     * Internal helper to get the text after tool execution
     */
    async getTextInternal() {
        await this.executeToolsIfNeeded();
        if (!this.finalResponse) {
            throw new Error('Response not available');
        }
        return extractTextFromResponse(this.finalResponse);
    }
    /**
     * Get just the text content from the response.
     * This will consume the stream until completion, execute any tools, and extract the text.
     */
    getText() {
        if (this.textPromise) {
            return this.textPromise;
        }
        this.textPromise = this.getTextInternal();
        return this.textPromise;
    }
    /**
     * Get the complete response object including usage information.
     * This will consume the stream until completion and execute any tools.
     * Returns the full OpenResponsesNonStreamingResponse with usage data (inputTokens, outputTokens, cachedTokens, etc.)
     */
    async getResponse() {
        await this.executeToolsIfNeeded();
        if (!this.finalResponse) {
            throw new Error('Response not available');
        }
        return this.finalResponse;
    }
    /**
     * Stream all response events as they arrive.
     * Multiple consumers can iterate over this stream concurrently.
     * Preliminary tool results are streamed in REAL-TIME as generator tools yield.
     */
    getFullResponsesStream() {
        return async function* () {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            // Get or create broadcaster for real-time tool events (lazy init prevents race conditions)
            const broadcaster = this.ensureBroadcaster();
            const toolEventConsumer = broadcaster.createConsumer();
            // Start tool execution in background (completes broadcaster when done)
            const executionPromise = this.executeToolsIfNeeded().finally(() => {
                broadcaster.complete();
            });
            const consumer = this.reusableStream.createConsumer();
            // Yield original API events
            for await (const event of consumer) {
                yield event;
            }
            // Yield tool preliminary results as they arrive (real-time!)
            for await (const event of toolEventConsumer) {
                yield {
                    type: 'tool.preliminary_result',
                    toolCallId: event.toolCallId,
                    result: event.result,
                    timestamp: Date.now(),
                };
            }
            // Ensure execution completed (handles errors)
            await executionPromise;
        }.call(this);
    }
    /**
     * Stream only text deltas as they arrive.
     * This filters the full event stream to only yield text content.
     */
    getTextStream() {
        return async function* () {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            yield* extractTextDeltas(this.reusableStream);
        }.call(this);
    }
    /**
     * Stream incremental message updates as content is added in responses format.
     * Each iteration yields an updated version of the message with new content.
     * Also yields OpenResponsesFunctionCallOutput after tool execution completes.
     * Returns ResponsesOutputMessage or OpenResponsesFunctionCallOutput compatible with OpenAI Responses API format.
     */
    getNewMessagesStream() {
        return async function* () {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            // First yield messages from the stream in responses format
            yield* buildResponsesMessageStream(this.reusableStream);
            // Execute tools if needed
            await this.executeToolsIfNeeded();
            // Yield function call outputs for each executed tool
            for (const round of this.allToolExecutionRounds) {
                for (const toolResult of round.toolResults) {
                    yield toolResult;
                }
            }
            // If tools were executed, yield the final message (if there is one)
            if (this.finalResponse && this.allToolExecutionRounds.length > 0) {
                // Check if the final response contains a message
                const hasMessage = this.finalResponse.output.some((item) => hasTypeProperty(item) && item.type === 'message');
                if (hasMessage) {
                    yield extractResponsesMessageFromResponse(this.finalResponse);
                }
            }
        }.call(this);
    }
    /**
     * Stream only reasoning deltas as they arrive.
     * This filters the full event stream to only yield reasoning content.
     */
    getReasoningStream() {
        return async function* () {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            yield* extractReasoningDeltas(this.reusableStream);
        }.call(this);
    }
    /**
     * Stream tool call argument deltas and preliminary results.
     * Preliminary results are streamed in REAL-TIME as generator tools yield.
     * - Tool call argument deltas as { type: "delta", content: string }
     * - Preliminary results as { type: "preliminary_result", toolCallId, result }
     */
    getToolStream() {
        return async function* () {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            // Get or create broadcaster for real-time tool events (lazy init prevents race conditions)
            const broadcaster = this.ensureBroadcaster();
            const toolEventConsumer = broadcaster.createConsumer();
            // Start tool execution in background (completes broadcaster when done)
            const executionPromise = this.executeToolsIfNeeded().finally(() => {
                broadcaster.complete();
            });
            // Yield tool deltas from API stream
            for await (const delta of extractToolDeltas(this.reusableStream)) {
                yield {
                    type: 'delta',
                    content: delta,
                };
            }
            // Yield tool events as they arrive (real-time!)
            for await (const event of toolEventConsumer) {
                yield event;
            }
            // Ensure execution completed (handles errors)
            await executionPromise;
        }.call(this);
    }
    /**
     * Get all tool calls from the completed response (before auto-execution).
     * Note: If tools have execute functions, they will be automatically executed
     * and this will return the tool calls from the initial response.
     * Returns structured tool calls with parsed arguments.
     */
    async getToolCalls() {
        await this.initStream();
        if (!this.reusableStream) {
            throw new Error('Stream not initialized');
        }
        const completedResponse = await consumeStreamForCompletion(this.reusableStream);
        return extractToolCallsFromResponse(completedResponse);
    }
    /**
     * Stream structured tool call objects as they're completed.
     * Each iteration yields a complete tool call with parsed arguments.
     */
    getToolCallsStream() {
        return async function* () {
            await this.initStream();
            if (!this.reusableStream) {
                throw new Error('Stream not initialized');
            }
            yield* buildToolCallStream(this.reusableStream);
        }.call(this);
    }
    /**
     * Cancel the underlying stream and all consumers
     */
    async cancel() {
        if (this.reusableStream) {
            await this.reusableStream.cancel();
        }
    }
}
//# sourceMappingURL=model-result.js.map