import type * as models from '../models/index.js';
import type { ReusableReadableStream } from './reusable-stream.js';
import type { ParsedToolCall, Tool } from './tool-types.js';
/**
 * Extract text deltas from responses stream events
 */
export declare function extractTextDeltas(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): AsyncIterableIterator<string>;
/**
 * Extract reasoning deltas from responses stream events
 */
export declare function extractReasoningDeltas(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): AsyncIterableIterator<string>;
/**
 * Extract tool call argument deltas from responses stream events
 */
export declare function extractToolDeltas(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): AsyncIterableIterator<string>;
/**
 * Build incremental message updates from responses stream events
 * Returns ResponsesOutputMessage (assistant/responses format)
 */
export declare function buildResponsesMessageStream(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): AsyncIterableIterator<models.ResponsesOutputMessage>;
/**
 * Build incremental message updates from responses stream events
 * Returns AssistantMessage (chat format) instead of ResponsesOutputMessage
 */
export declare function buildMessageStream(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): AsyncIterableIterator<models.AssistantMessage>;
/**
 * Consume stream until completion and return the complete response
 */
export declare function consumeStreamForCompletion(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): Promise<models.OpenResponsesNonStreamingResponse>;
/**
 * Extract the first message from a completed response (chat format)
 */
export declare function extractMessageFromResponse(response: models.OpenResponsesNonStreamingResponse): models.AssistantMessage;
/**
 * Extract the first message from a completed response (responses format)
 */
export declare function extractResponsesMessageFromResponse(response: models.OpenResponsesNonStreamingResponse): models.ResponsesOutputMessage;
/**
 * Extract text from a response, either from outputText or by concatenating message content
 */
export declare function extractTextFromResponse(response: models.OpenResponsesNonStreamingResponse): string;
/**
 * Extract all tool calls from a completed response
 * Returns parsed tool calls with arguments as objects (not JSON strings)
 */
export declare function extractToolCallsFromResponse(response: models.OpenResponsesNonStreamingResponse): ParsedToolCall<Tool>[];
/**
 * Build incremental tool call updates from responses stream events
 * Yields structured tool call objects as they're built from deltas
 */
export declare function buildToolCallStream(stream: ReusableReadableStream<models.OpenResponsesStreamEvent>): AsyncIterableIterator<ParsedToolCall<Tool>>;
/**
 * Check if a response contains any tool calls
 */
export declare function responseHasToolCalls(response: models.OpenResponsesNonStreamingResponse): boolean;
/**
 * Convert OpenResponsesNonStreamingResponse to ClaudeMessage format
 * Compatible with the Anthropic SDK BetaMessage type
 */
export declare function convertToClaudeMessage(response: models.OpenResponsesNonStreamingResponse): models.ClaudeMessage;
/**
 * Extract unsupported content by original type
 */
export declare function extractUnsupportedContent(message: models.ClaudeMessage, originalType: string): models.UnsupportedContent[];
/**
 * Check if message has any unsupported content
 */
export declare function hasUnsupportedContent(message: models.ClaudeMessage): boolean;
/**
 * Get summary of unsupported content types
 */
export declare function getUnsupportedContentSummary(message: models.ClaudeMessage): Record<string, number>;
//# sourceMappingURL=stream-transformers.d.ts.map