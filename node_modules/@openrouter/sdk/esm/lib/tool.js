import { ToolType, } from "./tool-types.js";
/**
 * Type guard to check if config is a generator tool config (has eventSchema)
 */
function isGeneratorConfig(config) {
    return "eventSchema" in config && config.eventSchema !== undefined;
}
/**
 * Type guard to check if config is a manual tool config (execute === false)
 */
function isManualConfig(config) {
    return config.execute === false;
}
// Implementation
export function tool(config) {
    // Check for manual tool first (execute === false)
    if (isManualConfig(config)) {
        const fn = {
            name: config.name,
            inputSchema: config.inputSchema,
        };
        if (config.description !== undefined) {
            fn.description = config.description;
        }
        if (config.nextTurnParams !== undefined) {
            fn.nextTurnParams = config.nextTurnParams;
        }
        return {
            type: ToolType.Function,
            function: fn,
        };
    }
    // Check for generator tool (has eventSchema)
    if (isGeneratorConfig(config)) {
        const fn = {
            name: config.name,
            inputSchema: config.inputSchema,
            eventSchema: config.eventSchema,
            outputSchema: config.outputSchema,
            // Types now align - config.execute matches the interface type
            execute: config.execute,
        };
        if (config.description !== undefined) {
            fn.description = config.description;
        }
        if (config.nextTurnParams !== undefined) {
            fn.nextTurnParams = config.nextTurnParams;
        }
        return {
            type: ToolType.Function,
            function: fn,
        };
    }
    // Regular tool (has execute function, no eventSchema)
    // TypeScript can't infer the relationship between TReturn and TOutput
    // So we build the object without type annotation, then return with correct type
    const functionObj = {
        name: config.name,
        inputSchema: config.inputSchema,
        execute: config.execute,
        ...(config.description !== undefined && { description: config.description }),
        ...(config.outputSchema !== undefined && { outputSchema: config.outputSchema }),
        ...(config.nextTurnParams !== undefined && { nextTurnParams: config.nextTurnParams }),
    };
    // The function signature guarantees this is type-safe via overloads
    return {
        type: ToolType.Function,
        function: functionObj,
    };
}
//# sourceMappingURL=tool.js.map