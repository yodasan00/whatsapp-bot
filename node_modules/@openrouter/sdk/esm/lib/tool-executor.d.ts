import type { $ZodType } from 'zod/v4/core';
import type { APITool, Tool, ParsedToolCall, ToolExecutionResult, TurnContext } from './tool-types.js';
import * as z4 from 'zod/v4';
export declare const ZodError: z4.z.core.$constructor<z4.ZodError<unknown>, z4.z.core.$ZodIssue[]>;
/**
 * Recursively remove keys prefixed with ~ from an object.
 * These are metadata properties (like ~standard from Standard Schema)
 * that should not be sent to downstream providers.
 * @see https://github.com/OpenRouterTeam/typescript-sdk/issues/131
 *
 * When given a Record<string, unknown>, returns Record<string, unknown>.
 * When given unknown, returns unknown (preserves primitives, null, etc).
 */
export declare function sanitizeJsonSchema(obj: Record<string, unknown>): Record<string, unknown>;
export declare function sanitizeJsonSchema(obj: unknown): unknown;
/**
 * Convert a Zod schema to JSON Schema using Zod v4's toJSONSchema function.
 * Accepts ZodType from the main zod package for user compatibility.
 * The resulting schema is sanitized to remove metadata properties (like ~standard)
 * that would cause 400 errors with downstream providers.
 */
export declare function convertZodToJsonSchema(zodSchema: $ZodType): Record<string, unknown>;
/**
 * Convert tools to OpenRouter API format
 * Accepts readonly arrays for better type compatibility
 */
export declare function convertToolsToAPIFormat(tools: readonly Tool[]): APITool[];
/**
 * Validate tool input against Zod schema
 * @throws ZodError if validation fails
 */
export declare function validateToolInput<T>(schema: $ZodType<T>, args: unknown): T;
/**
 * Validate tool output against Zod schema
 * @throws ZodError if validation fails
 */
export declare function validateToolOutput<T>(schema: $ZodType<T>, result: unknown): T;
/**
 * Parse tool call arguments from JSON string
 */
export declare function parseToolCallArguments(argumentsString: string): unknown;
/**
 * Execute a regular (non-generator) tool
 */
export declare function executeRegularTool(tool: Tool, toolCall: ParsedToolCall<Tool>, context: TurnContext): Promise<ToolExecutionResult<Tool>>;
/**
 * Execute a generator tool and collect preliminary and final results
 * - Intermediate yields are validated against eventSchema (preliminary events)
 * - Last yield is validated against outputSchema (final result sent to model)
 * - Generator must emit at least one value
 */
export declare function executeGeneratorTool(tool: Tool, toolCall: ParsedToolCall<Tool>, context: TurnContext, onPreliminaryResult?: (toolCallId: string, result: unknown) => void): Promise<ToolExecutionResult<Tool>>;
/**
 * Execute a tool call
 * Automatically detects if it's a regular or generator tool
 */
export declare function executeTool(tool: Tool, toolCall: ParsedToolCall<Tool>, context: TurnContext, onPreliminaryResult?: (toolCallId: string, result: unknown) => void): Promise<ToolExecutionResult<Tool>>;
/**
 * Find a tool by name in the tools array
 */
export declare function findToolByName(tools: Tool[], name: string): Tool | undefined;
/**
 * Format tool execution result as a string for sending to the model
 */
export declare function formatToolResultForModel(result: ToolExecutionResult<Tool>): string;
/**
 * Create a user-friendly error message for tool execution errors
 */
export declare function formatToolExecutionError(error: Error, toolCall: ParsedToolCall<Tool>): string;
//# sourceMappingURL=tool-executor.d.ts.map